<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="gMt7WMX3TJ" />
  <meta name="google-site-verification" content="PF62v7y-qoER_Bt0rTKDnp8VRGwDuOs0kLLGyg8SxJM" />
  
  <title>Go程序性能分析工具 | Peter&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在2011年的Scala鼎盛时期，Rober Hundt 发表了一篇论文Loop Recognition in C++/Java/Go/Scala. 这篇论文实现了一个特定的查找算法，例如在C++,Go,Java,Scala编译器中使用的代码流程分析，可以利用这个去画出一个程序运行的性能分析图。论文中展示的Go程序运行的相当缓慢，这是一个很好的机会来运用Go性能分析工具去分析这个缓慢程序，并使它运">
<meta name="keywords" content="golang,翻译">
<meta property="og:type" content="article">
<meta property="og:title" content="Go程序性能分析工具">
<meta property="og:url" content="http://godliness.github.io/2017/08/10/profiling-go-programs/index.html">
<meta property="og:site_name" content="Peter&#39;s Blog">
<meta property="og:description" content="在2011年的Scala鼎盛时期，Rober Hundt 发表了一篇论文Loop Recognition in C++/Java/Go/Scala. 这篇论文实现了一个特定的查找算法，例如在C++,Go,Java,Scala编译器中使用的代码流程分析，可以利用这个去画出一个程序运行的性能分析图。论文中展示的Go程序运行的相当缓慢，这是一个很好的机会来运用Go性能分析工具去分析这个缓慢程序，并使它运">
<meta property="og:updated_time" content="2017-08-16T03:02:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go程序性能分析工具">
<meta name="twitter:description" content="在2011年的Scala鼎盛时期，Rober Hundt 发表了一篇论文Loop Recognition in C++/Java/Go/Scala. 这篇论文实现了一个特定的查找算法，例如在C++,Go,Java,Scala编译器中使用的代码流程分析，可以利用这个去画出一个程序运行的性能分析图。论文中展示的Go程序运行的相当缓慢，这是一个很好的机会来运用Go性能分析工具去分析这个缓慢程序，并使它运">
  
    <link rel="alternative" href="/atom.xml" title="Peter&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.png">
  
  
      <link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">
  
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  <link rel="apple-touch-icon" href="/apple-touch-icon.png">
  
  
      <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  
  <!-- 加载特效 -->
    <script src="/js/pace.js"></script>
    <link href="/css/pace/pace-theme-flash.css" rel="stylesheet" />
  <script>
      var yiliaConfig = {
          rootUrl: '/',
          fancybox: true,
          animate: true,
          isHome: false,
          isPost: true,
          isArchive: false,
          isTag: false,
          isCategory: false,
          open_in_new: false
      }
  </script>
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            
            <img lazy-src="/img/head.jpg" class="js-avatar">
            
        </a>

        <hgroup>
          <h1 class="header-author"><a href="/" title="Hey Dude!">Peter Ma</a></h1>
        </hgroup>

        
        
        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
			<li onclick="location.href='/archives'">归档</li>
                        <li>标签</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fl mail" target="_blank" href="mailto:machaojms@126.com" title="mail">mail</a>
                            
                                <a class="fl github" target="_blank" href="https://github.com/godliness" title="github">github</a>
                            
                                <a class="fl zhihu" target="_blank" href="https://www.zhihu.com/people/godliness" title="zhihu">zhihu</a>
                            
                                <a class="fl weibo" target="_blank" href="http://weibo.com/1570530605" title="weibo">weibo</a>
                            
                                <a class="fl twitter" target="_blank" href="https://twitter.com/godlinesssss" title="twitter">twitter</a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <a href="/tags/elk/" style="font-size: 10px;">elk</a> <a href="/tags/etcd/" style="font-size: 10px;">etcd</a> <a href="/tags/golang/" style="font-size: 20px;">golang</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/大数据/" style="font-size: 13.33px;">大数据</a> <a href="/tags/微服务/" style="font-size: 10px;">微服务</a> <a href="/tags/数据结构，读书笔记/" style="font-size: 10px;">数据结构，读书笔记</a> <a href="/tags/监控/" style="font-size: 10px;">监控</a> <a href="/tags/翻译/" style="font-size: 13.33px;">翻译</a> <a href="/tags/读书笔记/" style="font-size: 16.67px;">读书笔记</a>
                    </div>
                </section>
                
                
                

                
                
                <section class="switch-part switch-part3">
                
                    <div id="js-aboutme">我是一只普普通通的程序猿，有个做全栈架构师的梦想，为了梦想可以放弃香蕉的猿！</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="Hey Dude!">Peter Ma</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                
                    <img lazy-src="/img/head.jpg" class="js-avatar">
                
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="Hey Dude!">Peter Ma</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                <div class="social">
                    
                        <a class="mail" target="_blank" href="mailto:machaojms@126.com" title="mail">mail</a>
                    
                        <a class="github" target="_blank" href="https://github.com/godliness" title="github">github</a>
                    
                        <a class="zhihu" target="_blank" href="https://www.zhihu.com/people/godliness" title="zhihu">zhihu</a>
                    
                        <a class="weibo" target="_blank" href="http://weibo.com/1570530605" title="weibo">weibo</a>
                    
                        <a class="twitter" target="_blank" href="https://twitter.com/godlinesssss" title="twitter">twitter</a>
                    
                </div>
            </nav>
        </header>                
    </div>
</nav>

      <div class="body-wrap"><article id="post-profiling-go-programs" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/08/10/profiling-go-programs/" class="article-date">
      <time datetime="2017-08-10T06:36:07.000Z" itemprop="datePublished">2017-08-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Go程序性能分析工具
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>在2011年的Scala鼎盛时期，Rober Hundt 发表了一篇论文<a href="http://research.google.com/pubs/pub37122.html" target="_blank" rel="external">Loop Recognition in C++/Java/Go/Scala.</a> 这篇论文实现了一个特定的查找算法，例如在C++,Go,Java,Scala编译器中使用的代码流程分析，可以利用这个去画出一个程序运行的性能分析图。论文中展示的Go程序运行的相当缓慢，这是一个很好的机会来运用Go性能分析工具去分析这个缓慢程序，并使它运行的快起来。</p>
<p>通过使用Go性能分析工具来找到程序正确的性能瓶颈，可以让Go程序运行的快一个数量级，并减少6倍的内存占用。（更新：由于最近的gcc里面libstdc++的优化，内存占用减少了3.7倍多）</p>
<p>Hundt的论文没有指定是使用的哪个版本的C++, Go, Java,和Scala工具。在这篇文章中，我们将使用最新的每周发布的6g Go编译器快照和Ubuntu Natty发行版附带g ++的版本。（我们将不会使用Java或者Scala,因为我们不擅长使用这些语言来写出有效率的程序，所以在这些语言中进行对比的话会有些不公平。由于C++是论文中所述最快的语言，所以和C++来进行对比就足够了。）（更新：在更新过的文章中，我们将要使用最近在amd64平台上开发的Go编译器的快照，并使用在2013年3月份发布的g++最新版本4.8.0）</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ go version</div><div class="line">go version devel +08d20469cc20 Tue Mar 26 08:27:18 2013 +0100 linux/amd64</div><div class="line">$ g++ --version</div><div class="line">g++ (GCC) 4.8.0</div><div class="line">Copyright (C) 2013 Free Software Foundation, Inc.</div><div class="line">...</div><div class="line">$</div></pre></td></tr></table></figure>
<p>这个程序运行在一个3.4GHz Core i7-2600 CPU 和 16 GB内存，Gentoo Linux’s 3.8.4-gentoo的内核的电脑上。 这个机器通过下面的命令禁用了CPU频率缩放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ sudo bash</div><div class="line"># for i in /sys/devices/system/cpu/cpu[0-7]</div><div class="line">do</div><div class="line">    echo performance &gt; $i/cpufreq/scaling_governor</div><div class="line">done</div><div class="line">#</div></pre></td></tr></table></figure>
<p>我们取<a href="https://github.com/hundt98847/multi-language-bench" target="_blank" rel="external">Hundt’s benchmark programs</a>程序中的C++和Go的版本，修改一下仅仅输出一行我们想要的信息。我们利用Linux time命令去输出用户消耗时间，系统消耗时间，实际消耗时间，和最大内存使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">$ cat xtime</div><div class="line">#!/bin/sh</div><div class="line">/usr/bin/time -f &apos;%Uu %Ss %er %MkB %C&apos; &quot;$@&quot;</div><div class="line">$</div><div class="line"></div><div class="line">$ make havlak1cc</div><div class="line">g++ -O3 -o havlak1cc havlak1.cc</div><div class="line">$ ./xtime ./havlak1cc</div><div class="line"># of loops: 76002 (total 3800100)</div><div class="line">loop-0, nest: 0, depth: 0</div><div class="line">17.70u 0.05s 17.80r 715472kB ./havlak1cc</div><div class="line">$</div><div class="line"></div><div class="line">$ make havlak1</div><div class="line">go build havlak1.go</div><div class="line">$ ./xtime ./havlak1</div><div class="line"># of loops: 76000 (including 1 artificial root node)</div><div class="line">25.05u 0.11s 25.20r 1334032kB ./havlak1</div><div class="line">$</div></pre></td></tr></table></figure>
<p>C++程序运行了17.8秒并且使用了700MB的内存。Go程序运行了25.2秒并且使用了1302MB内存。（这些测量很难与论文中的测量达成一致，但是本篇文章的重点是探索如何使用‘go tool pprof’工具，而不是重现论文中的结果。）</p>
<p>在开始调整Go程序之前，需要先开启profilling功能。如果程序代码使用了<a href="http://golang.org/pkg/testing/" target="_blank" rel="external">Go testing package</a>的benchmarking支持，我们也可以使用gotest’s的标准参数-cpuprofile和-memprofile。像在下面的单体程序中，我们需要引入包runtime/pprof并添加几行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var cpuprofile = flag.String(&quot;cpuprofile&quot;, &quot;&quot;, &quot;write cpu profile to file&quot;)</div><div class="line"></div><div class="line">func main() &#123;</div><div class="line">    flag.Parse()</div><div class="line">    if *cpuprofile != &quot;&quot; &#123;</div><div class="line">        f, err := os.Create(*cpuprofile)</div><div class="line">        if err != nil &#123;</div><div class="line">            log.Fatal(err)</div><div class="line">        &#125;</div><div class="line">        pprof.StartCPUProfile(f)</div><div class="line">        defer pprof.StopCPUProfile()</div><div class="line">    &#125;</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>新的代码定义了一个参数cpuprofile，调用这个<a href="http://golang.org/pkg/flag/" target="_blank" rel="external">Go flag library</a> 去解析命令行参数，如果传了cpuprofile参数， <a href="http://golang.org/pkg/runtime/pprof/#StartCPUProfile" target="_blank" rel="external">starts CPU profiling</a>就会重定向到那个参数所命名的文件中。这个分析器需要在程序退出之前调用一个<a href="http://golang.org/pkg/runtime/pprof/#StopCPUProfile" target="_blank" rel="external"><code>StopCPUProfile</code></a>方法来清空写入到文件中的缓冲内容。我们使用defer来确保main函数返回前函数被调用。<br>添加了如上代码后，我们就可以通过带上-cpuprofile参数来运行程序，然后运行<code>go roo pprof</code>去或者性能分析指标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ make havlak1.prof</div><div class="line">./havlak1 -cpuprofile=havlak1.prof</div><div class="line"># of loops: 76000 (including 1 artificial root node)</div><div class="line">$ go tool pprof havlak1 havlak1.prof</div><div class="line">Welcome to pprof!  For help, type &apos;help&apos;.</div><div class="line">(pprof)</div></pre></td></tr></table></figure>
<p>这个<code>go tool pprof</code> 命令就是<a href="https://github.com/gperftools/gperftools" target="_blank" rel="external">Google’s <code>pprof</code> C++ profiler</a>.的轻量级变种。最重要的命令就是topN，它可以展示出指标的前几个较大的数值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">(pprof) top10</div><div class="line">Total: 2525 samples</div><div class="line">     298  11.8%  11.8%      345  13.7% runtime.mapaccess1_fast64</div><div class="line">     268  10.6%  22.4%     2124  84.1% main.FindLoops</div><div class="line">     251   9.9%  32.4%      451  17.9% scanblock</div><div class="line">     178   7.0%  39.4%      351  13.9% hash_insert</div><div class="line">     131   5.2%  44.6%      158   6.3% sweepspan</div><div class="line">     119   4.7%  49.3%      350  13.9% main.DFS</div><div class="line">      96   3.8%  53.1%       98   3.9% flushptrbuf</div><div class="line">      95   3.8%  56.9%       95   3.8% runtime.aeshash64</div><div class="line">      95   3.8%  60.6%      101   4.0% runtime.settype_flush</div><div class="line">      88   3.5%  64.1%      988  39.1% runtime.mallocgc</div></pre></td></tr></table></figure>
<p>当启用CPU分析时，Go程序每秒钟停止大约100次，并将当前运行的goroutine堆栈中的程序计数器的样本记录下来。该配置文件具有2525个样本，因此运行时间超出了25秒。在 <code>go tool pprof</code> 的输出中，每个函数都会有一行数据指标在样例中。前两列展示了函数运行的样例数量（而不是一个调用过的函数的次数），作为原始数量以及占总样本数量的百分比。这个runtime.mapaccess1_fast64函数运行了298个样例，或者占总样例数的11.8%。前十个输出是按照样例数进行排序的。第三列展示了前几行所运行样本数量的总和占总样本数量的百分比：前三行就占用了32.5%。第四列和第五列展示了函数出现的次数（包括正在运行的和调用过的次数总和）. 这个main.FindLoops函数的运行占了总采样的10.6%,但是它在调用栈中的次数占用了总采样的84.1%.</p>
<p>通过使用参数-cum对第四列和第五列的排序得到如下输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(pprof) top5 -cum</div><div class="line">Total: 2525 samples</div><div class="line">       0   0.0%   0.0%     2144  84.9% gosched0</div><div class="line">       0   0.0%   0.0%     2144  84.9% main.main</div><div class="line">       0   0.0%   0.0%     2144  84.9% runtime.main</div><div class="line">       0   0.0%   0.0%     2124  84.1% main.FindHavlakLoops</div><div class="line">     268  10.6%  10.6%     2124  84.1% main.FindLoops</div><div class="line">(pprof) top5 -cum</div></pre></td></tr></table></figure>
<p>实际上main.FindLoops和main.main的总和应该是100％，但每个堆栈样本只包括最下面的100个堆栈帧;在大约四分之一的样本中，递归的main.DFS函数比main.main深了100多个帧，所以完整的跟踪被截断了。</p>
<p>堆栈跟踪样本包含有比文本列表可以显示的数据更有趣的函数调用关系数据。 Web命令以SVG格式写入配置文件数据图，并在Web浏览器中打开。（还有一个gv命令写入PostScript，并在Ghostview中打开它，对于任一命令，您需要安装graphviz。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(pprof) web</div></pre></td></tr></table></figure>
<p>图片的一部分 <a href="https://rawgit.com/rsc/benchgraffiti/master/havlak/havlak1.svg" target="_blank" rel="external">the full graph</a>看起来像这样:</p>
<p>图中的每个框对应于单个函数，并且框的大小根据运行函数的采样数量来确定。从框X到框Y的连线表示X调用Y;沿边缘的数字代表调用所出现在样本中的次数。如果调用单个函数在样本中出现了多次，例如在递归函数调用期间，每个外观都会计入边缘权重。这解释了21342次的次数从main.DFS到它自己的函数框。</p>
<p>一目了然，我们可以看到该程序花费了大量时间在哈希操作中，原因是Go使用了map值。我们也可以告诉Web命令只使用包含特定函数的示例，例如runtime.mapaccess1_fast64，它排除了图中无用的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(pprof) web mapaccess1</div></pre></td></tr></table></figure>
<p>如果我们看一眼的话，我们可以看到main.FindLoops和main.DFS正在对runtime.mapaccess1_fast64进行调用。</p>
<p>现在我们对大局有了一个粗略的概念，现在是放大特定功能的时候了。我们先来看看main.DFS，因为它是一个较短的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(pprof) list DFS</div><div class="line">Total: 2525 samples</div><div class="line">ROUTINE ====================== main.DFS in /home/rsc/g/benchgraffiti/havlak/havlak1.go</div><div class="line">   119    697 Total samples (flat / cumulative)</div><div class="line">     3      3  240: func DFS(currentNode *BasicBlock, nodes []*UnionFindNode, number map[*BasicBlock]int, last []int, current int) int &#123;</div><div class="line">     1      1  241:     nodes[current].Init(currentNode, current)</div><div class="line">     1     37  242:     number[currentNode] = current</div><div class="line">     .      .  243:</div><div class="line">     1      1  244:     lastid := current</div><div class="line">    89     89  245:     for _, target := range currentNode.OutEdges &#123;</div><div class="line">     9    152  246:             if number[target] == unvisited &#123;</div><div class="line">     7    354  247:                     lastid = DFS(target, nodes, number, last, lastid+1)</div><div class="line">     .      .  248:             &#125;</div><div class="line">     .      .  249:     &#125;</div><div class="line">     7     59  250:     last[number[currentNode]] = lastid</div><div class="line">     1      1  251:     return lastid</div><div class="line">(pprof)</div></pre></td></tr></table></figure>
<p>这条命令展示了函数DFS的源码（实际上，他会匹配满足正则表达式DFS的所有函数）。</p>
<p>前三列是运行该行时采集的样本数，运行该行或从该行调用的代码中采集的样本数以及文件中的行号。相应的命令disasm显示函数的反汇编代码而不是源代码;当有足够的样本时，这可以帮助您了解哪些命令比较消耗性能。这个 <code>weblist</code> 命令混合了两种模式: 它会返回这样的输出 <a href="https://rawgit.com/rsc/benchgraffiti/master/havlak/havlak1.html" target="_blank" rel="external">a source listing in which clicking a line shows the disassembly</a>.</p>
<p>由于我们已经知道时间都消耗在哈希运行时函数实现的map查找上，所以我们最关心的是第二列。在递归调用DFS（第247行）中花费了大量时间，正如递归遍历所预期的那样耗时。除了递归以外，看起来像是时间消耗在对第242,246和250行的map映射的访问。对于这种查找，map不是最有效的选择。就像它们在编译器中一样，基本块结构具有分配给它们的唯一序列号。而不是使用map[* BasicBlock] int，我们可以使用[] int，一个由块号索引的切片。可以用数组以及切片代替使用的，尽量不要是用map。将number从map更改为切片需要在程序中修改7行代码，这样它的运行时间将会缩短2倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ make havlak2</div><div class="line">go build havlak2.go</div><div class="line">$ ./xtime ./havlak2</div><div class="line"># of loops: 76000 (including 1 artificial root node)</div><div class="line">16.55u 0.11s 16.69r 1321008kB ./havlak2</div><div class="line">$</div></pre></td></tr></table></figure>
<p>(可以看看这个连接 <a href="https://github.com/rsc/benchgraffiti/commit/58ac27bcac3ffb553c29d0b3fb64745c91c95948" target="_blank" rel="external">diff between <code>havlak1</code> and <code>havlak2</code></a>)</p>
<p>我们可以再运行一次性能分析，函数main.DFS不再是运行时所消耗的最大部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$ make havlak2.prof</div><div class="line">./havlak2 -cpuprofile=havlak2.prof</div><div class="line"># of loops: 76000 (including 1 artificial root node)</div><div class="line">$ go tool pprof havlak2 havlak2.prof</div><div class="line">Welcome to pprof!  For help, type &apos;help&apos;.</div><div class="line">(pprof)</div><div class="line">(pprof) top5</div><div class="line">Total: 1652 samples</div><div class="line">     197  11.9%  11.9%      382  23.1% scanblock</div><div class="line">     189  11.4%  23.4%     1549  93.8% main.FindLoops</div><div class="line">     130   7.9%  31.2%      152   9.2% sweepspan</div><div class="line">     104   6.3%  37.5%      896  54.2% runtime.mallocgc</div><div class="line">      98   5.9%  43.5%      100   6.1% flushptrbuf</div><div class="line">(pprof)</div></pre></td></tr></table></figure>
<p>这个main.DFS没有再出现在性能数据中，并且剩下的程序运行时间也降了下来。现在程序所消耗的时间大多数都花费在内存分配以及垃圾回收中（runtime.mallocgc, 这个函数会周期性的运行内存分配以及垃圾回收，大概占用总时间的54.2%）.去找出为什么垃圾回收器占用了这么多时间，那我们就不得不找出什么分配的内存。一种方法就是添加内存性能分析到程序中。如果提供了-memprofile标志，程序将在循环查找的一次迭代后停止，写入内存数据到文件中然后退出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var memprofile = flag.String(&quot;memprofile&quot;, &quot;&quot;, &quot;write memory profile to this file&quot;)</div><div class="line">...</div><div class="line"></div><div class="line">    FindHavlakLoops(cfgraph, lsgraph)</div><div class="line">    if *memprofile != &quot;&quot; &#123;</div><div class="line">        f, err := os.Create(*memprofile)</div><div class="line">        if err != nil &#123;</div><div class="line">            log.Fatal(err)</div><div class="line">        &#125;</div><div class="line">        pprof.WriteHeapProfile(f)</div><div class="line">        f.Close()</div><div class="line">        return</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们调用程序通过-memprofile参数来输出一个性能分析文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ make havlak3.mprof</div><div class="line">go build havlak3.go</div><div class="line">./havlak3 -memprofile=havlak3.mprof</div><div class="line">$</div></pre></td></tr></table></figure>
<p>(可以看一下 <a href="https://github.com/rsc/benchgraffiti/commit/b78dac106bea1eb3be6bb3ca5dba57c130268232" target="_blank" rel="external">diff from havlak2</a>)</p>
<p>我们使用和<code>go tool pprof</code>完全一样的方式。 现在我们正在检查的样本是内存分配，而不是cpu占用时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof havlak3 havlak3.mprof</div><div class="line">Adjusting heap profiles for 1-in-524288 sampling rate</div><div class="line">Welcome to pprof!  For help, type &apos;help&apos;.</div><div class="line">(pprof) top5</div><div class="line">Total: 82.4 MB</div><div class="line">    56.3  68.4%  68.4%     56.3  68.4% main.FindLoops</div><div class="line">    17.6  21.3%  89.7%     17.6  21.3% main.(*CFG).CreateNode</div><div class="line">     8.0   9.7%  99.4%     25.6  31.0% main.NewBasicBlockEdge</div><div class="line">     0.5   0.6% 100.0%      0.5   0.6% itab</div><div class="line">     0.0   0.0% 100.0%      0.5   0.6% fmt.init</div><div class="line">(pprof)</div></pre></td></tr></table></figure>
<p>这个命令<code>go tool pprof</code> 展示出，函数FindLoops大约占用了总内存82.4MB的56.3MB内存；另一个CreateNode函数占用了17.6MB内存. 为了减少开销，内存分析器仅记录每半兆字节分配大约一个块的信息（“1-in-524288采样率”），因此这些是实际计数的近似值。</p>
<p>找到具体的内存占用，我们可以遍历出这些函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(pprof) list FindLoops</div><div class="line">Total: 82.4 MB</div><div class="line">ROUTINE ====================== main.FindLoops in /home/rsc/g/benchgraffiti/havlak/havlak3.go</div><div class="line">  56.3   56.3 Total MB (flat / cumulative)</div><div class="line">...</div><div class="line">   1.9    1.9  268:     nonBackPreds := make([]map[int]bool, size)</div><div class="line">   5.8    5.8  269:     backPreds := make([][]int, size)</div><div class="line">     .      .  270:</div><div class="line">   1.9    1.9  271:     number := make([]int, size)</div><div class="line">   1.9    1.9  272:     header := make([]int, size, size)</div><div class="line">   1.9    1.9  273:     types := make([]int, size, size)</div><div class="line">   1.9    1.9  274:     last := make([]int, size, size)</div><div class="line">   1.9    1.9  275:     nodes := make([]*UnionFindNode, size, size)</div><div class="line">     .      .  276:</div><div class="line">     .      .  277:     for i := 0; i &lt; size; i++ &#123;</div><div class="line">   9.5    9.5  278:             nodes[i] = new(UnionFindNode)</div><div class="line">     .      .  279:     &#125;</div><div class="line">...</div><div class="line">     .      .  286:     for i, bb := range cfgraph.Blocks &#123;</div><div class="line">     .      .  287:             number[bb.Name] = unvisited</div><div class="line">  29.5   29.5  288:             nonBackPreds[i] = make(map[int]bool)</div><div class="line">     .      .  289:     &#125;</div><div class="line">...</div></pre></td></tr></table></figure>
<p>看起来当前的瓶颈和上一个一样：在可以用简单数据结构的地方却使用了map。FindLoops函数占用了大约29.5MB的内存。</p>
<p>另外，如果我们使用–inuse_objects标志运行<code>go tool pprof</code>，它会报告分配次数计数而不是内存占用大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof --inuse_objects havlak3 havlak3.mprof</div><div class="line">Adjusting heap profiles for 1-in-524288 sampling rate</div><div class="line">Welcome to pprof!  For help, type &apos;help&apos;.</div><div class="line">(pprof) list FindLoops</div><div class="line">Total: 1763108 objects</div><div class="line">ROUTINE ====================== main.FindLoops in /home/rsc/g/benchgraffiti/havlak/havlak3.go</div><div class="line">720903 720903 Total objects (flat / cumulative)</div><div class="line">...</div><div class="line">     .      .  277:     for i := 0; i &lt; size; i++ &#123;</div><div class="line">311296 311296  278:             nodes[i] = new(UnionFindNode)</div><div class="line">     .      .  279:     &#125;</div><div class="line">     .      .  280:</div><div class="line">     .      .  281:     // Step a:</div><div class="line">     .      .  282:     //   - initialize all nodes as unvisited.</div><div class="line">     .      .  283:     //   - depth-first traversal and numbering.</div><div class="line">     .      .  284:     //   - unreached BB&apos;s are marked as dead.</div><div class="line">     .      .  285:     //</div><div class="line">     .      .  286:     for i, bb := range cfgraph.Blocks &#123;</div><div class="line">     .      .  287:             number[bb.Name] = unvisited</div><div class="line">409600 409600  288:             nonBackPreds[i] = make(map[int]bool)</div><div class="line">     .      .  289:     &#125;</div><div class="line">...</div><div class="line">(pprof)</div></pre></td></tr></table></figure>
<p>由于大约~200,000的map占用了29.5MB的内存，map的初始化占用了大约150字节。用map来存储键值对是合理的，但是用map来存储简单的集合结构就多此一举了。</p>
<p>我们可以使用简单的数据切片来替代map去遍历元素。有一个例外的就是使用map来做实现去重算法，因为map的key是不可能重复的。但也可以使用内嵌函数来来实现这个功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">func appendUnique(a []int, x int) []int &#123;</div><div class="line">    for _, y := range a &#123;</div><div class="line">        if x == y &#123;</div><div class="line">            return a</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return append(a, x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了写这个函数外，让这个Go程序来使用数组切片去替代map还需要修改几行代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ make havlak4</div><div class="line">go build havlak4.go</div><div class="line">$ ./xtime ./havlak4</div><div class="line"># of loops: 76000 (including 1 artificial root node)</div><div class="line">11.84u 0.08s 11.94r 810416kB ./havlak4</div><div class="line">$</div></pre></td></tr></table></figure>
<p>(参考<a href="https://github.com/rsc/benchgraffiti/commit/245d899f7b1a33b0c8148a4cd147cb3de5228c8a" target="_blank" rel="external">diff from havlak3</a>)</p>
<p>现在我们比之前开始的时候快了2.11几倍。让我们再看一下CPU的性能分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">$ make havlak4.prof</div><div class="line">./havlak4 -cpuprofile=havlak4.prof</div><div class="line"># of loops: 76000 (including 1 artificial root node)</div><div class="line">$ go tool pprof havlak4 havlak4.prof</div><div class="line">Welcome to pprof!  For help, type &apos;help&apos;.</div><div class="line">(pprof) top10</div><div class="line">Total: 1173 samples</div><div class="line">     205  17.5%  17.5%     1083  92.3% main.FindLoops</div><div class="line">     138  11.8%  29.2%      215  18.3% scanblock</div><div class="line">      88   7.5%  36.7%       96   8.2% sweepspan</div><div class="line">      76   6.5%  43.2%      597  50.9% runtime.mallocgc</div><div class="line">      75   6.4%  49.6%       78   6.6% runtime.settype_flush</div><div class="line">      74   6.3%  55.9%       75   6.4% flushptrbuf</div><div class="line">      64   5.5%  61.4%       64   5.5% runtime.memmove</div><div class="line">      63   5.4%  66.8%      524  44.7% runtime.growslice</div><div class="line">      51   4.3%  71.1%       51   4.3% main.DFS</div><div class="line">      50   4.3%  75.4%      146  12.4% runtime.MCache_Alloc</div><div class="line">(pprof)</div></pre></td></tr></table></figure>
<p>现在内存分配和紧跟着的垃圾收集（runtime.mallocgc）占我们运行时间的50.9％。 查看系统为什么是垃圾回收在占用运行时间的另一种方法是查看什么导致的垃圾回收，从下图可以看出大部分时间用在了mallocgc函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(pprof) web mallocgc</div></pre></td></tr></table></figure>
<p>从这个图很难看出发生了什么，因为有包含了太多的小节点,从而掩盖了大的节点。我们可以告诉<code>go tool pprof</code>不必去计算小于10%的样本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go tool pprof --nodefraction=0.1 havlak4 havlak4.prof</div><div class="line">Welcome to pprof!  For help, type &apos;help&apos;.</div><div class="line">(pprof) web mallocgc</div></pre></td></tr></table></figure>
<p>我们现在可以轻松跟随粗箭头，看看FindLoops是触发大部分的垃圾收集的函数。如果我们列出FindLoops函数，我们可以看到开始的是否大多都是正确的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">(pprof) list FindLoops</div><div class="line">...</div><div class="line">     .      .  270: func FindLoops(cfgraph *CFG, lsgraph *LSG) &#123;</div><div class="line">     .      .  271:     if cfgraph.Start == nil &#123;</div><div class="line">     .      .  272:             return</div><div class="line">     .      .  273:     &#125;</div><div class="line">     .      .  274:</div><div class="line">     .      .  275:     size := cfgraph.NumNodes()</div><div class="line">     .      .  276:</div><div class="line">     .    145  277:     nonBackPreds := make([][]int, size)</div><div class="line">     .      9  278:     backPreds := make([][]int, size)</div><div class="line">     .      .  279:</div><div class="line">     .      1  280:     number := make([]int, size)</div><div class="line">     .     17  281:     header := make([]int, size, size)</div><div class="line">     .      .  282:     types := make([]int, size, size)</div><div class="line">     .      .  283:     last := make([]int, size, size)</div><div class="line">     .      .  284:     nodes := make([]*UnionFindNode, size, size)</div><div class="line">     .      .  285:</div><div class="line">     .      .  286:     for i := 0; i &lt; size; i++ &#123;</div><div class="line">     2     79  287:             nodes[i] = new(UnionFindNode)</div><div class="line">     .      .  288:     &#125;</div><div class="line">...</div><div class="line">(pprof)</div></pre></td></tr></table></figure>
<p>每当FindLoops被调用时，它都会分配一些相当大的数据结构。由于benchmark调用了FindLoops 50次，这些加起来就累积了大量的垃圾，所以就产生了大量的垃圾回收操作。</p>
<p>使用垃圾回收语言并不意味着您就可以忽略内存分配问题。 在这种情况下，一个简单的解决方案是引入缓存，以便每次调用FindLoops可以会重用以前的分配的调用存储。 （事实上，在Hundt的论文中，他解释说，Java程序需要这个改变才能得到任何合理的性能，但是在其他垃圾回收的实现中他并没有做同样的改变。）</p>
<p>我们将添加一个全局缓存结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var cache struct &#123;</div><div class="line">    size int</div><div class="line">    nonBackPreds [][]int</div><div class="line">    backPreds [][]int</div><div class="line">    number []int</div><div class="line">    header []int</div><div class="line">    types []int</div><div class="line">    last []int</div><div class="line">    nodes []*UnionFindNode</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，我们可以让FindLoops函数去用这个缓存结构来替代内存的分配：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">if cache.size &lt; size &#123;</div><div class="line">    cache.size = size</div><div class="line">    cache.nonBackPreds = make([][]int, size)</div><div class="line">    cache.backPreds = make([][]int, size)</div><div class="line">    cache.number = make([]int, size)</div><div class="line">    cache.header = make([]int, size)</div><div class="line">    cache.types = make([]int, size)</div><div class="line">    cache.last = make([]int, size)</div><div class="line">    cache.nodes = make([]*UnionFindNode, size)</div><div class="line">    for i := range cache.nodes &#123;</div><div class="line">        cache.nodes[i] = new(UnionFindNode)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">nonBackPreds := cache.nonBackPreds[:size]</div><div class="line">for i := range nonBackPreds &#123;</div><div class="line">    nonBackPreds[i] = nonBackPreds[i][:0]</div><div class="line">&#125;</div><div class="line">backPreds := cache.backPreds[:size]</div><div class="line">for i := range nonBackPreds &#123;</div><div class="line">    backPreds[i] = backPreds[i][:0]</div><div class="line">&#125;</div><div class="line">number := cache.number[:size]</div><div class="line">header := cache.header[:size]</div><div class="line">types := cache.types[:size]</div><div class="line">last := cache.last[:size]</div><div class="line">nodes := cache.nodes[:size]</div></pre></td></tr></table></figure>
<p>类似这种全局变量的使用是不好的工程实践，当然这意味着对FindLoops的并发调用现在是不安全的。 现在，我们正在进行尽可能小的改变，以了解对我们的程序性能至关重要的地方在哪里; 这个变化很简单，并且反映了Java实现中的代码。 Go程序的最终版本将使用单独的LoopFinder实例来跟踪此内存，从而恢复并发使用的可能性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ make havlak5</div><div class="line">go build havlak5.go</div><div class="line">$ ./xtime ./havlak5</div><div class="line"># of loops: 76000 (including 1 artificial root node)</div><div class="line">8.03u 0.06s 8.11r 770352kB ./havlak5</div><div class="line">$</div></pre></td></tr></table></figure>
<p>（参考<a href="https://github.com/rsc/benchgraffiti/commit/2d41d6d16286b8146a3f697dd4074deac60d12a4" target="_blank" rel="external">diff from havlak4</a>）</p>
<p>我们可以做更多的工作来清理程序并使其运行的更快，但目前所展示的都需要性能分析才可以进行程序优化。在函数FindLoops遍历的内部循环中使用的工作列表其实可以重复使用，并且可以与在该过程中生成的单例“节点池”配合使用。 类似地，循环图存储可以在每次迭代上重用，而不是重新分配。 除了这些性能变化，最终版本是使用惯用的Go风格，使用数据结构和方法编写的。 风格变化对运行时间影响不大：算法和约束并没有改变。</p>
<p>最终的修改版本运行时间为2.29秒并占用了351MB的内存：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ make havlak6</div><div class="line">go build havlak6.go</div><div class="line">$ ./xtime ./havlak6</div><div class="line"># of loops: 76000 (including 1 artificial root node)</div><div class="line">2.26u 0.02s 2.29r 360224kB ./havlak6</div><div class="line">$</div></pre></td></tr></table></figure>
<p>目前程序运行的时间比之前快了11倍。即使我们禁用重用生成循环图功能，仅仅在循环中查找bookeeping时来进行缓存，那运行的速度也比之前的快了6.7倍多，占用的内存比之前少了1.5倍多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ ./xtime ./havlak6 -reuseloopgraph=false</div><div class="line"># of loops: 76000 (including 1 artificial root node)</div><div class="line">3.69u 0.06s 3.76r 797120kB ./havlak6 -reuseloopgraph=false</div><div class="line">$</div></pre></td></tr></table></figure>
<p>当然，将此Go程序与原始C ++程序进行比较是不公平的，该程序使用诸如<code>set</code>的低效数据结构，而使用<code>vector</code>会比较合适一些。作为完备性测，我们将最终的Go程序翻译成<a href="https://github.com/rsc/benchgraffiti/blob/master/havlak/havlak6.cc" target="_blank" rel="external">equivalent C++ code</a>.。 它的执行时间类似于Go程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ make havlak6cc</div><div class="line">g++ -O3 -o havlak6cc havlak6.cc</div><div class="line">$ ./xtime ./havlak6cc</div><div class="line"># of loops: 76000 (including 1 artificial root node)</div><div class="line">1.99u 0.19s 2.19r 387936kB ./havlak6cc</div></pre></td></tr></table></figure>
<p>Go程序的运行速度几乎和C ++程序一样快。 由于C ++程序正在使用自动删除和分配而不是显式缓存，所以C ++程序有点缩短并且易于编写，但并不是很明显：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ wc havlak6.cc; wc havlak6.go</div><div class="line"> 401 1220 9040 havlak6.cc</div><div class="line"> 461 1441 9467 havlak6.go</div><div class="line">$</div></pre></td></tr></table></figure>
<p>(参考 <a href="https://github.com/rsc/benchgraffiti/blob/master/havlak/havlak6.cc" target="_blank" rel="external">havlak6.cc</a> 和 <a href="https://github.com/rsc/benchgraffiti/blob/master/havlak/havlak6.go" target="_blank" rel="external">havlak6.go</a>)</p>
<p>Benchmarks测试与其测量的程序一样好。 我们使用<code>go tool pprof</code>来研究一个低效的Go程序，然后将其性能提高一个数量级，并将其内存使用量降低3.7倍。 与等效优化的C ++程序的后续比较表明，当程序员注意内部循环生成多少垃圾时，Go可以与C ++竞争。</p>
<p>程序源代码，Linux x86-64二进制文件和配置文件可以在GitHub的 <a href="https://github.com/rsc/benchgraffiti/" target="_blank" rel="external">benchgraffiti project on GitHub</a>中找到。</p>
<p>如上所述，<code>go test</code>已经包括这些分析标志：定义一个 <a href="http://golang.org/pkg/testing/" target="_blank" rel="external">benchmark function</a>，而且你都设置好了。 还有一个用于分析数据的标准HTTP接口。 在HTTP服务器中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import _ &quot;net/http/pprof&quot;</div></pre></td></tr></table></figure>
<p>这个导入将会为/debug /pprof /下的几个URL安装处理程序。 然后，您可以使用单个参数运行<code>go tool pprof</code> - 服务器的分析数据的URL，它将下载一个实时的profile分析文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go tool pprof http://localhost:6060/debug/pprof/profile   # 30-second CPU profile</div><div class="line">go tool pprof http://localhost:6060/debug/pprof/heap      # heap profile</div><div class="line">go tool pprof http://localhost:6060/debug/pprof/block     # goroutine blocking profile</div></pre></td></tr></table></figure>
<p>By Russ Cox, July 2011; updated by Shenghou Ma, May 2013，翻译 马超。</p>

      
      
        <div class="page-reward">
          <p><a href="javascript:void(0)" onclick="dashangToggle()" class="dashang" title="打赏，支持一下">赏</a></p>
          <div class="hide_box"></div>
          <div class="shang_box">
            <a class="shang_close" href="javascript:void(0)" onclick="dashangToggle()" title="关闭">×</a>
            <div class="shang_tit">
              <p>多谢客官</p>
            </div>
            <div class="shang_payimg">
              <img src="/img/alipayimg.jpg" alt="扫码支持" title="扫一扫" />
            </div>
              <div class="pay_explain">扫码打赏，你说多少就多少</div>
            <div class="shang_payselect">
              
                <div class="pay_item checked" data-id="alipay">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/alipay.png" alt="支付宝" /></span>
                </div>
              
              
                <div class="pay_item" data-id="wechat">
                  <span class="radiobox"></span>
                  <span class="pay_logo"><img src="/img/weipay.png" alt="微信" /></span>
                </div>
              
            </div>
            <div class="shang_info">
              <p>打开<span id="shang_pay_txt">支付宝</span>扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
        </div>
        <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
        <script type="text/javascript">
          $(".pay_item").click(function(){
            $(this).addClass('checked').siblings('.pay_item').removeClass('checked');
            var dataid=$(this).attr('data-id');
            $(".shang_payimg img").attr("src","/img/"+dataid+"img.jpg");
            $("#shang_pay_txt").text(dataid=="alipay"?"支付宝":"微信");
          });
          function dashangToggle(){
            $(".hide_box").fadeToggle();
            $(".shang_box").fadeToggle();
          }
        </script>
      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2017/08/10/profiling-go-programs/">Go程序性能分析工具</a></p>
        <p><span>文章作者:</span><a href="/" title="访问 Peter Ma 的个人博客">Peter Ma</a></p>
        <p><span>发布时间:</span>2017年08月10日 - 14时36分</p>
        <p><span>最后更新:</span>2017年08月16日 - 11时02分</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2017/08/10/profiling-go-programs/" title="Go程序性能分析工具">http://godliness.github.io/2017/08/10/profiling-go-programs/</a>
            <span class="copy-path" data-clipboard-text="原文: http://godliness.github.io/2017/08/10/profiling-go-programs/　　作者: Peter Ma" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script src="/js/clipboard.min.js"></script>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" title="中国大陆 (CC BY-NC-SA 3.0 CN)" target = "_blank">"署名-非商用-相同方式共享 3.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



<nav id="article-nav">
  
    <a href="/2017/08/18/linux-command-record/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          应用程序调优所需的一些Linux命令
        
      </div>
    </a>
  
  
    <a href="/2017/06/22/thinking-in-java/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">Java编程思想</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>

    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
</div>
<input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

<script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script>
    var valueHide = "隐藏目录";
    var valueShow = "显示目录";

    if ($(".left-col").is(":hidden")) {
        $("#tocButton").attr("value", valueShow);
    }
    $("#tocButton").click(function() {
        if ($("#toc").is(":hidden")) {
            $("#tocButton").attr("value", valueHide);
            $("#toc").slideDown(320);
        }
        else {
            $("#tocButton").attr("value", valueShow);
            $("#toc").slideUp(350);
        }
    })
    if ($(".toc").length < 1) {
        $("#toc, #tocButton").hide();
    }
</script>





<div class="bdsharebuttonbox">
	<a href="#" class="fx fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
	<a href="#" class="fx fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信"></a>
	<a href="#" class="fx fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友"></a>
	<a href="#" class="fx fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook"></a>
	<a href="#" class="fx fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter"></a>
	<a href="#" class="fx fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a>
	<a href="#" class="fx fa-files-o bds_copy" data-cmd="copy" title="分享到复制网址"></a>
</div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>




    



    <div class="scroll" id="post-nav-button">
        
            <a href="/2017/08/18/linux-command-record/" title="上一篇: 应用程序调优所需的一些Linux命令">
                <i class="fa fa-angle-left"></i>
            </a>
        
        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>
        
            <a href="/2017/06/22/thinking-in-java/" title="下一篇: Java编程思想">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>
    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/28/data-structure-record/">数据结构概述</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/21/microservice-monitor-introduce/">说说微服务与监控</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/18/linux-command-record/">应用程序调优所需的一些Linux命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/10/profiling-go-programs/">Go程序性能分析工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/22/thinking-in-java/">Java编程思想</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/09/mysql-install/">MYAQL5.7安装</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/09/elk-install/">采用ELK进行网络流量分析的安装过程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/25/go-in-action-records/">Go In Action</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/06/go-language-study-records/">Go语言学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/30/install-etcd-teach/">部署etcd简易教程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/20/go-comments-review/">Go语言CodeReivew注释总结</a></li></ul>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
    <script>
        $(".post-list").addClass("toc-article");
        $(".post-list-item a").attr("target","_blank");
        $("#post-nav-button > a:nth-child(2)").click(function() {
            $(".fa-bars, .fa-times").toggle();
            $(".post-list").toggle(300);
            if ($(".toc").length > 0) {
                $("#toc, #tocButton").toggle(200, function() {
                    if ($(".switch-area").is(":visible")) {
                        $("#tocButton").attr("value", valueHide);
                        }
                    })
            }
            else {
            }
        })
    </script>



    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                &copy; 2017 Peter Ma
            </div>
            <div class="footer-right">
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" >访客到访数: 
                            <span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>, </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit">本页阅读量: 
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
    <script src="https://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>

    <script>
        $(document).ready(function() {
            var backgroundnum = 24;
            var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
            $("#mobile-nav").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
            $(".left-col").css({"background-image": backgroundimg,"background-size": "cover","background-position": "center"});
        })
    </script>




	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "//hm.baidu.com/hm.js?e735c584171a3058be972b115ad6ef45";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>


<div class="scroll" id="scroll">
    <a href="#"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments"><i class="fa fa-comments-o"></i></a>
    <a href="#footer"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    $(document).ready(function() {
        if ($("#comments").length < 1) {
            $("#scroll > a:nth-child(2)").hide();
        };
    })
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

  <script language="javascript">
    $(function() {
        $("a[title]").each(function() {
            var a = $(this);
            var title = a.attr('title');
            if (title == undefined || title == "") return;
            a.data('title', title).removeAttr('title').hover(

            function() {
                var offset = a.offset();
                $("<div id=\"anchortitlecontainer\"></div>").appendTo($("body")).html(title).css({
                    top: offset.top - a.outerHeight() - 15,
                    left: offset.left + a.outerWidth()/2 + 1
                }).fadeIn(function() {
                    var pop = $(this);
                    setTimeout(function() {
                        pop.remove();
                    }, pop.text().length * 800);
                });
            }, function() {
                $("#anchortitlecontainer").remove();
            });
        });
    });
</script>


  </div>
</body>
</html>